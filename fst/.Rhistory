#create an incidence matrix
# Incidence matrix
incMat_a <- model.matrix(~ coldata$admix - 1)
colnames(incMat_a) <- gsub(pattern = 'ids\\$admix', replacement = "",
x = colnames(incMat_a))
rownames(incMat_a) <- rownames(coldata)
incMat_h <- model.matrix(~coldata$habitat - 1)
colnames(incMat_h) <- gsub(pattern = 'ids\\$habitat', replacement = "",
x = colnames(incMat_h))
rownames(incMat_h) <- rownames(coldata)
#load bams
bams <- read.table("bams_noclones", header = F)[,1]
bams <- gsub("_s2.trim.bt2.bam","",bams)
#load kinship matrix
kmat <- as.matrix(fread("newres",data.table = F))
kmat2 <- as.data.frame(subset(kmat, select = c("a","b","rab")))
kmat3 <- acast(kmat2, a~b, value.var='rab', fill=NULL, drop = F)
kmat3 <- cbind("0"=NA, kmat3)
kmat3 <- rbind(kmat3, "97"=NA)
#assign row and column names
rownames(kmat3) <- bams
colnames(kmat3) <- bams
#make the bottom diagonal mirror the top diagonal
makeSymm <- function(m) {
m[lower.tri(m)] <- t(m)[lower.tri(m)]
return(m)
}
kmat4 <- makeSymm(kmat3)
#make NA = 1
kmat4[is.na(kmat4)] <- 1
#rename to match og script
K_ldak <- kmat4
View(K_ldak)
View(coldata)
bams <- gsub("_s2.trim.bt2.bam","",gsub("-r","",bams))
#load kinship matrix
kmat <- as.matrix(fread("newres",data.table = F))
kmat2 <- as.data.frame(subset(kmat, select = c("a","b","rab")))
kmat3 <- acast(kmat2, a~b, value.var='rab', fill=NULL, drop = F)
kmat3 <- cbind("0"=NA, kmat3)
kmat3 <- rbind(kmat3, "97"=NA)
#assign row and column names
rownames(kmat3) <- bams
colnames(kmat3) <- bams
#make the bottom diagonal mirror the top diagonal
makeSymm <- function(m) {
m[lower.tri(m)] <- t(m)[lower.tri(m)]
return(m)
}
kmat4 <- makeSymm(kmat3)
#make NA = 1
kmat4[is.na(kmat4)] <- 1
#rename to match og script
K_ldak <- kmat4
#confusion here down:
K_ok <- K_ldak[match(unique(rownames(coldata)), rownames(K_ldak)),
match(unique(rownames(coldata)), colnames(K_ldak))]
View(K_ok)
View(coldata)
load("~/Library/CloudStorage/Dropbox/Research/FLKeys_trans2_age/mcav_files/vsd_age.mcav.RData")
#create an incidence matrix
# Incidence matrix
incMat_a <- model.matrix(~ coldata_common$admix - 1)
colnames(incMat_a) <- gsub(pattern = 'ids\\$admix', replacement = "",
x = colnames(incMat_a))
rownames(incMat_a) <- rownames(coldata_common)
incMat_h <- model.matrix(~coldata$habitat - 1)
colnames(incMat_h) <- gsub(pattern = 'ids\\$habitat', replacement = "",
x = colnames(incMat_h))
rownames(incMat_h) <- rownames(coldata_common)
incMat_h <- model.matrix(~coldata$habitat - 1)
incMat_h <- model.matrix(~coldata_common$habitat - 1)
colnames(incMat_h) <- gsub(pattern = 'ids\\$habitat', replacement = "",
x = colnames(incMat_h))
rownames(incMat_h) <- rownames(coldata_common)
#load bams
bams <- read.table("bams_noclones", header = F)[,1]
bams <- gsub("_s2.trim.bt2.bam","",gsub("-r","",bams))
#load kinship matrix
kmat <- as.matrix(fread("newres",data.table = F))
kmat2 <- as.data.frame(subset(kmat, select = c("a","b","rab")))
kmat3 <- acast(kmat2, a~b, value.var='rab', fill=NULL, drop = F)
kmat3 <- cbind("0"=NA, kmat3)
kmat3 <- rbind(kmat3, "97"=NA)
#assign row and column names
rownames(kmat3) <- bams
colnames(kmat3) <- bams
#make the bottom diagonal mirror the top diagonal
makeSymm <- function(m) {
m[lower.tri(m)] <- t(m)[lower.tri(m)]
return(m)
}
kmat4 <- makeSymm(kmat3)
#make NA = 1
kmat4[is.na(kmat4)] <- 1
#rename to match og script
K_ldak <- kmat4
#confusion here down:
K_ok <- K_ldak[match(unique(rownames(coldata_common)), rownames(K_ldak)),
match(unique(rownames(coldata_common)), colnames(K_ldak))]
View(vsd)
Kw <- K_ok
# matrice d apparentement populations
Kb <- matrix(NA,
nrow = length(levels(rownames(coldata_common))),
ncol = length(levels(rownames(coldata_common))))
rownames(Kb) <- levels(rownames(coldata_common))
colnames(Kb) <- levels(rownames(coldata_common))
Genotype
for (i in levels(rownames(coldata_common))) {
for (j in levels(rownames(coldata_common)))
}
View(coldata_common)
Kb[i, j] <- mean(K_ok[subset(coldata_common, habitat == i)$admix,
subset(coldata_common, habitat == j)$admix])
for (i in levels(rownames(coldata_common))) {
for (j in levels(rownames(coldata_common))) {
Kb[i, j] <- mean(K_ok[subset(coldata_common, habitat == i)$admix,
subset(coldata_common, habitat == j)$admix])
}
}
View(Kb)
for (i in levels(rownames(coldata_common))) {
for (j in levels(rownames(coldata_common))) {
Kb[i, j] <- mean(K_ok)
}
}
## ----genotype model calculation v2, message=FALSE-------------------------------------------------------------------------------
a <- proc.time()
cl <- makeCluster(numberOfThreads)
??makeCluster
library(data.table)
library(tidyverse)
library(dplyr)
library(reshape2)
cl <- makeCluster(numberOfThreads)
library(flashClust)
cl <- makeCluster(numberOfThreads)
library("doParallel")
cl <- makeCluster(numberOfThreads)
numberOfThreads <- 24
cl <- makeCluster(numberOfThreads)
registerDoParallel(cl)
avancement <- 0
genParFull <- c('(G_2_2_1_1+G_3_3_1_1)/(G_2_2_1_1+G_3_3_1_1+R_1_1)',
'G_2_2_1_1/(G_2_2_1_1+2*G_3_3_1_1)')
## ----genotype model calculation v2, message=FALSE-------------------------------------------------------------------------------
#load counts data
load("~/Dropbox/Research/FLKeys_trans2_age/mcav_files/vsd_age.mcav.RData")
#rename vsd to tcounts.trans (I think these are equivalent files counts that have been transformed)
tcounts.trans <- vsd
genesAPasser <- 1:ncol(tcounts.trans)
#make vectors of coldata (what I think that those things are in colonnesASelectionner)
bams <- rownames(coldata_common)
#make vectors of coldata (what I think that those things are in colonnesASelectionner)
ids <- rownames(coldata_common)
View(coldata_common)
age <- coldata_common$age
admix <- coldata_common$admix
habitat <- coldata_common$habiatat
colonnesASelectionner <- c("ids","age","admix","habitat")
if (all(rawCovsOk$Genotype_Bloc == rownames(tcounts.trans) %>% strsplit("_") %>%
lapply(function(x) paste(x[2:3], collapse = "_")))) {
data_breedR <- cbind(as.data.frame(rawCovsOk)[,colonnesASelectionner],
tcounts.trans)
} else {
break()
}
View(vsd)
#make rawCovsOk
rawCovsOk <- rawCovs[ids %in% colnames(vsd)]
#make rawCovsOk
rawCovsOk <- coldata_common[ids %in% colnames(vsd)]
#make rawCovsOk
rawCovsOk <- coldata_common
if (all(rawCovsOk$Genotype_Bloc == rownames(tcounts.trans) %>% strsplit("_") %>%
lapply(function(x) paste(x[2:3], collapse = "_")))) {
data_breedR <- cbind(as.data.frame(rawCovsOk)[,colonnesASelectionner],
tcounts.trans)
} else {
break()
}
View(rawCovsOk)
rawCovsOk$ids <- rownames(coldata_common)
if (all(rawCovsOk$Genotype_Bloc == rownames(tcounts.trans) %>% strsplit("_") %>%
lapply(function(x) paste(x[2:3], collapse = "_")))) {
data_breedR <- cbind(as.data.frame(rawCovsOk)[,colonnesASelectionner],
tcounts.trans)
} else {
break()
}
View(vsd)
#rename vsd to tcounts.trans (I think these are equivalent files counts that have been transformed)
tcounts.trans <- t(vsd)
genesAPasser <- 1:ncol(tcounts.trans)
#make vectors of coldata (what I think that those things are in colonnesASelectionner)
ids <- rownames(coldata_common)
age <- coldata_common$age
admix <- coldata_common$admix
habitat <- coldata_common$habiatat
colonnesASelectionner <- c("ids","age","admix","habitat")
#make rawCovsOk
rawCovsOk <- coldata_common
rawCovsOk$ids <- rownames(coldata_common)
if (all(rawCovsOk$Genotype_Bloc == rownames(tcounts.trans) %>% strsplit("_") %>%
lapply(function(x) paste(x[2:3], collapse = "_")))) {
data_breedR <- cbind(as.data.frame(rawCovsOk)[,colonnesASelectionner],
tcounts.trans)
} else {
break()
}
data_breedR$Heure_prelev <- as.factor(format(round.POSIXt(as.POSIXct(
data_breedR$Heure_prelev, format = "%H:%M", tz = "UTC"), units = "hours"),
format = "%H:%M"))
View(data_breedR)
varList <- foreach(j = genesAPasser,
.packages = c("breedR")) %dopar%
{
# avancement <- avancement + 1
dataset <- data_breedR[, c(1:4, j + 4)]
colnames(dataset)[c(1,5)] <- c("genot_id", "expr")
message(j)
#
#   dataset$expr <- tcounts.trans[, j]
mod1 <- NULL
try(mod1 <- suppressMessages(
remlf90(fixed = expr ~ DatePrelev + Heure_prelev + Bloc,
generic = list(pop_ids = list(incMat_p, KbNorm),
genot_ids = list(incMat_g, KwNorm)),
data = dataset,
method = "em")),
silent = TRUE)
if (is.null(mod1)) { break() }
blupGenotPlusPop <- incMat_gg %*% as.matrix(
mod1$ranef$pop_ids[[1]]$value) + mod1$ranef$genot_ids[[1]]$value
blupGenotPlusPop <- blupGenotPlusPop[,1]
blupGenot <- mod1$ranef$genot_ids[[1]]$value
names(blupGenot) <- names(blupGenotPlusPop)
phenAjusted <- mod1$effects$pop_ids$effects[[1]]$incidence.matrix %*%
as.matrix(mod1$ranef$pop_ids[[1]]$value) +
mod1$effects$genot_ids$effects[[1]]$incidence.matrix %*%
as.matrix(mod1$ranef$genot_ids[[1]]$value) +
residuals(mod1) + mean(dataset$expr)
nPA <- rownames(phenAjusted)
phenAjusted <- as.vector(phenAjusted)
names(phenAjusted) <- nPA
moyAjParGenot <- aggregate(phenAjusted ~ gsub("_[13]$", "", genot_id), mean,
data = dataset)
genot <- moyAjParGenot[,1]
moyAjParGenot <- moyAjParGenot[,2]
names(moyAjParGenot) <- genot
list(Variances = mod1$var[, "Estimated variances"],
`BLUP Genot + Pop` = blupGenotPlusPop,
`BLUP Genot` = blupGenot,
AIC_wGenot = mod1$fit$AIC,
`Adjusted Means Per Genotype` = moyAjParGenot,
`Adjusted Phenotype` = phenAjusted)
}
install.packages("breedR")
varList <- foreach(j = genesAPasser,
.packages = c("breedR")) %dopar%
{
# avancement <- avancement + 1
dataset <- data_breedR[, c(1:4, j + 4)]
colnames(dataset)[c(1,5)] <- c("genot_id", "expr")
message(j)
#
#   dataset$expr <- tcounts.trans[, j]
mod1 <- NULL
try(mod1 <- suppressMessages(
remlf90(fixed = expr ~ DatePrelev + Heure_prelev + Bloc,
generic = list(pop_ids = list(incMat_p, KbNorm),
genot_ids = list(incMat_g, KwNorm)),
data = dataset,
method = "em")),
silent = TRUE)
if (is.null(mod1)) { break() }
blupGenotPlusPop <- incMat_gg %*% as.matrix(
mod1$ranef$pop_ids[[1]]$value) + mod1$ranef$genot_ids[[1]]$value
blupGenotPlusPop <- blupGenotPlusPop[,1]
blupGenot <- mod1$ranef$genot_ids[[1]]$value
names(blupGenot) <- names(blupGenotPlusPop)
phenAjusted <- mod1$effects$pop_ids$effects[[1]]$incidence.matrix %*%
as.matrix(mod1$ranef$pop_ids[[1]]$value) +
mod1$effects$genot_ids$effects[[1]]$incidence.matrix %*%
as.matrix(mod1$ranef$genot_ids[[1]]$value) +
residuals(mod1) + mean(dataset$expr)
nPA <- rownames(phenAjusted)
phenAjusted <- as.vector(phenAjusted)
names(phenAjusted) <- nPA
moyAjParGenot <- aggregate(phenAjusted ~ gsub("_[13]$", "", genot_id), mean,
data = dataset)
genot <- moyAjParGenot[,1]
moyAjParGenot <- moyAjParGenot[,2]
names(moyAjParGenot) <- genot
list(Variances = mod1$var[, "Estimated variances"],
`BLUP Genot + Pop` = blupGenotPlusPop,
`BLUP Genot` = blupGenot,
AIC_wGenot = mod1$fit$AIC,
`Adjusted Means Per Genotype` = moyAjParGenot,
`Adjusted Phenotype` = phenAjusted)
}
varList <- foreach(j = genesAPasser,
.packages = c("breedR")) %dopar%
{
# avancement <- avancement + 1
dataset <- data_breedR[, c(1:4, j + 4)]
colnames(dataset)[c(1,5)] <- c("genot_id", "expr")
message(j)
#
#   dataset$expr <- tcounts.trans[, j]
mod1 <- NULL
try(mod1 <- suppressMessages(
remlf90(fixed = expr ~ DatePrelev + Heure_prelev + Bloc,
generic = list(pop_ids = list(incMat_p, KbNorm),
genot_ids = list(incMat_g, KwNorm)),
data = dataset,
method = "em")),
silent = TRUE)
if (is.null(mod1)) { break() }
blupGenotPlusPop <- incMat_gg %*% as.matrix(
mod1$ranef$pop_ids[[1]]$value) + mod1$ranef$genot_ids[[1]]$value
blupGenotPlusPop <- blupGenotPlusPop[,1]
blupGenot <- mod1$ranef$genot_ids[[1]]$value
names(blupGenot) <- names(blupGenotPlusPop)
phenAjusted <- mod1$effects$pop_ids$effects[[1]]$incidence.matrix %*%
as.matrix(mod1$ranef$pop_ids[[1]]$value) +
mod1$effects$genot_ids$effects[[1]]$incidence.matrix %*%
as.matrix(mod1$ranef$genot_ids[[1]]$value) +
residuals(mod1) + mean(dataset$expr)
nPA <- rownames(phenAjusted)
phenAjusted <- as.vector(phenAjusted)
names(phenAjusted) <- nPA
moyAjParGenot <- aggregate(phenAjusted ~ gsub("_[13]$", "", genot_id), mean,
data = dataset)
genot <- moyAjParGenot[,1]
moyAjParGenot <- moyAjParGenot[,2]
names(moyAjParGenot) <- genot
list(Variances = mod1$var[, "Estimated variances"],
`BLUP Genot + Pop` = blupGenotPlusPop,
`BLUP Genot` = blupGenot,
AIC_wGenot = mod1$fit$AIC,
`Adjusted Means Per Genotype` = moyAjParGenot,
`Adjusted Phenotype` = phenAjusted)
}
varList <- foreach(j = genesAPasser,
.packages = c("breedR")) %dopar%
{
# avancement <- avancement + 1
dataset <- data_breedR[, c(1:4, j + 4)]
colnames(dataset)[c(1,5)] <- c("genot_id", "expr")
message(j)
#
#   dataset$expr <- tcounts.trans[, j]
mod1 <- NULL
try(mod1 <- suppressMessages(
remlf90(fixed = expr ~ DatePrelev + Heure_prelev + Bloc,
generic = list(pop_ids = list(incMat_p, KbNorm),
genot_ids = list(incMat_g, KwNorm)),
data = dataset,
method = "em")),
silent = TRUE)
if (is.null(mod1)) { break() }
blupGenotPlusPop <- incMat_gg %*% as.matrix(
mod1$ranef$pop_ids[[1]]$value) + mod1$ranef$genot_ids[[1]]$value
blupGenotPlusPop <- blupGenotPlusPop[,1]
blupGenot <- mod1$ranef$genot_ids[[1]]$value
names(blupGenot) <- names(blupGenotPlusPop)
phenAjusted <- mod1$effects$pop_ids$effects[[1]]$incidence.matrix %*%
as.matrix(mod1$ranef$pop_ids[[1]]$value) +
mod1$effects$genot_ids$effects[[1]]$incidence.matrix %*%
as.matrix(mod1$ranef$genot_ids[[1]]$value) +
residuals(mod1) + mean(dataset$expr)
nPA <- rownames(phenAjusted)
phenAjusted <- as.vector(phenAjusted)
names(phenAjusted) <- nPA
moyAjParGenot <- aggregate(phenAjusted ~ gsub("_[13]$", "", genot_id), mean,
data = dataset)
genot <- moyAjParGenot[,1]
moyAjParGenot <- moyAjParGenot[,2]
names(moyAjParGenot) <- genot
list(Variances = mod1$var[, "Estimated variances"],
`BLUP Genot + Pop` = blupGenotPlusPop,
`BLUP Genot` = blupGenot,
AIC_wGenot = mod1$fit$AIC,
`Adjusted Means Per Genotype` = moyAjParGenot,
`Adjusted Phenotype` = phenAjusted)
}
# avancement <- avancement + 1
dataset <- data_breedR[, c(1:4, j + 4)]
j = genesAPasser
# avancement <- avancement + 1
dataset <- data_breedR[, c(1:4, j + 4)]
colnames(dataset)[c(1,5)] <- c("genot_id", "expr")
message(j)
#
#   dataset$expr <- tcounts.trans[, j]
mod1 <- NULL
try(mod1 <- suppressMessages(
remlf90(fixed = expr ~ DatePrelev + Heure_prelev + Bloc,
generic = list(pop_ids = list(incMat_p, KbNorm),
genot_ids = list(incMat_g, KwNorm)),
data = dataset,
method = "em")),
silent = TRUE)
if (is.null(mod1)) { break() }
View(dataset)
j = genesAPasser
# avancement <- avancement + 1
dataset <- data_breedR[, c(1:4, j + 4)]
colnames(dataset)[c(1,5)] <- c("ids", "expr")
View(dataset)
View(dataset)
View(data_breedR)
#### FST: compare differentially expressed genes with genetic differentiation
library(tidyverse)
library(dplyr)
library(DESeq2)
library(viridis)
library(cowplot)
##### pairwise genes #########
load("Not_in_paper_anymore/fst_files/mcavsnps_adults.rdata")
# Pairwise per-locus Fst
fst.files <- list.files('Not_in_paper_anymore/fst_files/outputs_from_tacc/')
fst.ls <- list()
for (i in fst.files) {
fst.ls[[gsub('\\.fst', '', i)]] <- read.table(paste0('Not_in_paper_anymore/fst_files/outputs_from_tacc/', i))
}
#deseq models
load("mcav_files/realModels.adults.RData")
##### pairwise genes #########
load("Not_in_paper_anymore/fst_files/mcavsnps_adults.rdata")
load("~/Library/CloudStorage/Dropbox/Research/FLKeys_trans2_adults/Not_in_paper_anymore/fst_files/mcavsnps_adults.rdata")
##### pairwise genes #########
load("fst_files/mcavsnps_adults.rdata")
# Pairwise per-locus Fst
fst.files <- list.files('fst_files/outputs_from_tacc/')
fst.ls <- list()
fst.ls[[gsub('\\.fst', '', i)]] <- read.table(paste0('fst_files/outputs_from_tacc/', i))
for (i in fst.files) {
fst.ls[[gsub('\\.fst', '', i)]] <- read.table(paste0('fst_files/outputs_from_tacc/', i))
}
load("~/Library/CloudStorage/Dropbox/Research/FLKeys_trans2_adults/mcav_files/realModels.adults.RData")
#No filtering of DEG or FST by top % fst or adjusted p-val
### Choose pairwise comparison ###
# dds.a = reduced ~habitat (LRT test)
# dds.admix = ~admix
# dds.combo = ~h.a (habitat+admix column)
# dds.full = ~habitat + admix
# dds.h = reduced ~admix (LRT test)
# dds.habitat = ~habitat
pair2compare <- results(dds.a,contrast=c("admix","N1","O2"))
#log2fold change values from DESeq results
deseq.pval <- data.frame(gene = gsub("-RA", "", rownames(pair2compare)), log2fold = pair2compare$log2FoldChange)
pair.degs <- filter(deseq.pval)
# Count the number of SNPs per gene
snps.per.gene <- group_by(allsnps2, gene) %>% summarise(n_snps = n())
#plot log2fold change vs. Fst
fst.log2foldchange.df <- fst.ls[['p12']] %>%
mutate(V3 = ifelse(V3 < 0, 0, V3)) %>%
mutate(pos = paste(V1, V2, sep = ':')) %>%
right_join(snp_coord2, by = 'pos') %>%
group_by(gene)%>%
summarise(fst = sum(V3)/sum(V3+V4))%>%
left_join(pair.degs, by = 'gene') %>%
filter(!is.na(log2fold)) %>%
filter(!is.na(fst))
overallfst <- fst.ls[['p12']] %>%
mutate(V3 = ifelse(V3 < 0, 0, V3)) %>%
summarise(ofst = sum(V3)/sum(V3+V4))
ggplot(fst.log2foldchange.df, aes(y = log2fold, x = fst))+
ylab(bquote(log[2]~ foldchange))+
xlab(bquote(F[ST]))+
geom_hex(bins = 30)+
scale_fill_viridis(trans="log10") +
#ggtitle("Nearshore v. Offshore Ecomorph") +
theme_cowplot()+
theme(plot.title = element_text(hjust = 0.5))+
geom_vline(xintercept = overallfst$ofst)
# function to draw ngenes at random ntimes, order, compute mean and sd
# (returns a list of 2 items: mean and sd)
meanq=function(x, ntimes, ngenes=100){
dd=list()
for (i in 1:ntimes) {
dx=sample(x,ngenes)
dx=dx[order(dx)]
dd[[i]]=dx
}
dd=do.call(cbind,dd)
return(list(apply(dd,1,mean),apply(dd,1,sd)))
}
# assuming you have a vector of all your Fsts called Fst:
#make vector of all fsts
Fst = fst.log2foldchange.df$fst
# logit-transform all your Fsts first:
logit <- function(x,add=0.01){
x[x<0]=0
x=x+add
return(log(x/(1-x)))
}
Fst = logit(Fst)
# these are Fsts for top 100 genes in each module
# (replace with actual code to extract those, this is just faking data to make sure code works)
toplg = lg_fst_top$fst
########fst by genes in modules#####
topfst <- function(x){
goinput = read.csv(paste0("mcav_go/",x,".csv"))
top1 = inner_join(goinput,fst.log2foldchange.df)
top2 = top1[order(top1$Fish_kME, decreasing = TRUE),]
return(top2[1:100,])
}
dg_fst_top = topfst("darkgrey")
